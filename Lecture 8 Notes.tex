\documentclass[14pt]{extarticle}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{scribe}
\usepackage{listings}
\usepackage{relsize}
\usepackage{xlop}
\usepackage{multirow,bigdelim,dcolumn,booktabs}
\usepackage[linesnumbered,vlined]{algorithm2e}
\usepackage{tikz}
\usepackage{float}
\usetikzlibrary{trees}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows,shapes,automata,petri,positioning,calc,arrows.meta}
\tikzset{
    >=Stealth, % makes the arrow heads bold
    every state/.style={thick},
    every  edge/.append style={->, thick, font=\footnotesize},
}

\Scribe{Aditya Diwakar}
\Lecturer{Frederic Faulkner}
\LectureNumber{8}
\LectureDate{February 3, 2022}
\LectureTitle{More DP}

\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\lstset{style=mystyle}
\setlength{\parindent}{0pt}

\begin{document}
	\MakeScribeTop

    The next lecture (Tuesday) is going to be a review sesion. The exam will
    be in the same lecture room. Also as a reminder, the notes must be
    handwritten on a singular side of a piece of paper.

    \subsection*{Longest Increasing Subsequence}
    We are interested in the longest increasing subsequence. A subsequence
    is any number of elements in the same order as an original array with
    optional gaps between elements.\\

    Increasing, in this context, means we want every next element in the
    subsequence to be greater than the previous element.\\

    As a reminder, the steps to give a DP solution are as such:
    \begin{enumerate}
        \item What does each entry represent in the table?
        \item What is the recurrence relation between table entries?
        \item How do you implement your dynamic programming algorithm?
        \item Perform a running time analysis.
    \end{enumerate}

    A naive approach to this question involves computing every possible
    subsequenece, computing how many are strictly increasing, and then finding
    the subsequence with largest strictly increasing length. However, this
    requires computing $2^n$ subsequences (bad!).\\

    Alternatively, let $T[i]$ represent the longest increasing subsequence
    from $a_1, \ldots, a_i$ (it may not include $a_i$, but it is the
    answer from the first to $ith$ element).

    Below is an example of the table filled in based on this entry definition:

    % 5 8 -1 9 2 6 3 10 4 7
    \begin{center}
        \begin{tikzpicture}
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                label={[label distance=0.3cm]180:array},
            ] (q1) at (0,0){$5$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q1,
            ] (q2) {$8$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q2,
            ] (q3) {$-1$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q3,
            ] (q4) {$9$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q4,
            ] (q5) {$2$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q5,
            ] (q6) {$6$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q6,
            ] (q7) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q7,
            ] (q8) {$10$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q8,
            ] (q9) {$4$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q9,
            ] (q10) {$7$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                below=0.5cm of q1,
                label={[label distance=0.3cm]180:$T[i]$},
            ] (j1) {$1$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j1,
            ] (j2) {$2$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j2,
            ] (j3) {$2$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j3,
            ] (j4) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j4,
            ] (j5) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j5,
            ] (j6) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j6,
            ] (j7) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j7,
            ] (j8) {$4$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j8,
            ] (j9) {$4$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j9,
            ] (j10) {$5$};
        \end{tikzpicture}
    \end{center}

    We can fill in this table because we can see the small subsequences
    that exist in this array, but notice from the above that the subsequences
    we were tracking ($5, 8, 9, 10$ or $-1, 2, 6, 10$ or $-1, 2, 3, 10$) are
    none of the valid subsequences, as the $T[i]$ with $5$ corresponds
    with the subsequence $-1, 2, 3, 4, 7$. Hence, this definition for
    entries does not work.\\

    Instead, we can choose to let $T[i] =$ the length of the longest increasing
    subsequence in $a_1, \ldots, a_i$ that includes $a_i$. Now, in the
    same example as above, we have:

    \begin{center}
        \begin{tikzpicture}
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                label={[label distance=0.3cm]180:array},
            ] (q1) at (0,0){$5$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q1,
            ] (q2) {$8$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q2,
            ] (q3) {$-1$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q3,
            ] (q4) {$9$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q4,
            ] (q5) {$2$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q5,
            ] (q6) {$6$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q6,
            ] (q7) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q7,
            ] (q8) {$10$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q8,
            ] (q9) {$4$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q9,
            ] (q10) {$7$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                below=0.5cm of q1,
                label={[label distance=0.3cm]180:$T[i]$},
            ] (j1) {$1$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j1,
            ] (j2) {$2$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j2,
            ] (j3) {$1$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j3,
            ] (j4) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j4,
            ] (j5) {$2$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j5,
            ] (j6) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j6,
            ] (j7) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j7,
            ] (j8) {$4$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j8,
            ] (j9) {$4$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j9,
            ] (j10) {$5$};
        \end{tikzpicture}
    \end{center}

    \vspace{-2mm}
    The recurrence relationship is given by:
    \begin{align*}
        T[i] = 1 + \max_{\forall j\leq 1: a_j < a_i}\left(
            T[j]
        \right)
    \end{align*}
    \vspace{-1mm}
    unlike before where no recurrence relationship existed. This algorthim
    could be implemented like so (in pseudocode):

    \begin{algorithm}[H]
        \SetKwFunction{FMain}{LIS}
        \SetKwProg{Fn}{Function}{:}{}
        \Fn{\FMain{$a_1, \ldots, a_n$}}{
            \tcc{let $T$ be an empty $n$ long list}
            $T\gets []$                   \\
            \For{$i\in 1\to n$}{
                $T[i] \gets 1$              \\
                \For{$j\in 1\to i - 1$}{
                    \If{$a_j < a_i$}{
                        $T[i] \gets \max(T[i], T[j] + 1)$
                    }
                }
            }
            \tcc{answer is not simply $T[n]$, rather it is max of table}
            $ret \gets 1$       \\
            \For{$i\in 1\to n$}{
                $ret \gets max(ret, T[i])$
            }
            \Return $ret$
        }
    \end{algorithm}

    The running time of this algorithm is $O(n^2)$ for the double nested loop
    and $O(n)$ for the max function, giving $O(n^2) + O(n) = O(n^2)$ as
    the total runtime.

    \subsection*{Largest Sum Subarray}
    Let's say we have an input $a_1, \ldots, a_n$ (allowing for negative
    numbers), then we want a subarray with the maximum sum (a subarray
    is not the same as a subsequence, subarrays must be contiguous).\\

    Let $T[i]$ be the maximum sum subarray in $a_1, \ldots, a_i$ that
    includes $a_i$, so what is our recurrence relation? Since we always
    include $a_i$, that is always part of the relation.\\

    Now, if we use $a_i$, maybe we choose to use the highest possible
    from the previous (we can either use this or nothing at all). Since
    $T[i-1]$ is gives this maximum sum for the previous index, we can pick
    it if it makes our sum bigger (positive).

    Hence, the recurrence relation is given by:
    \begin{align*}
        T[i] = a_i + \max(T[i-1], 0)
    \end{align*}

    An example of this could be:
    \begin{center}
        \begin{tikzpicture}
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                label={[label distance=0.3cm]180:array},
            ] (q1) at (0,0){$5$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q1,
            ] (q2) {$-9$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q2,
            ] (q3) {$1$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q3,
            ] (q4) {$2$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q4,
            ] (q5) {$-1$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of q5,
            ] (q6) {$5$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                below=0.5cm of q1,
                label={[label distance=0.3cm]180:$T[i]$},
            ] (j1) {$5$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j1,
            ] (j2) {$-4$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j2,
            ] (j3) {$1$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j3,
            ] (j4) {$3$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j4,
            ] (j5) {$2$};
            \node[draw,
                rect,
                minimum width=1cm,
                minimum height=0.5cm,
                right=0cm of j5,
            ] (j6) {$7$};
        \end{tikzpicture}
    \end{center}

    In pseudocode, this would be implemeneted as:

    \begin{algorithm}[H]
        \SetKwFunction{FMain}{MaxSumSubarray}
        \SetKwProg{Fn}{Function}{:}{}
        \Fn{\FMain{$a_1, \ldots, a_n$}}{
            \tcc{let $T$ be an empty $n$ long list}
            $T\gets []$                     \\
            $T[1] \gets a_1$                \\
            \For{$i\in 2\to n$}{
                $T[i] \gets a_i + \max(T[i-1], 0)$              \\
            }
            \tcc{answer is not simply $T[n]$, rather it is max of table}
            $ret \gets -\infty$       \\
            \For{$i\in 1\to n$}{
                $ret \gets max(ret, T[i])$
            }
            \Return $ret$
        }
    \end{algorithm}

    \subsection*{Challenge Questions: Off by One Subsequence}

    We can represent $T[i]$ as the length of longest off by one subsequence
    from $a_i, \ldots, a_i$ that includes $a_i$. Hence, the recurrence
    relation is given by:
    \begin{align*}
        T[i] = 1 + \max_{\forall j\leq 1: |a_j - a_i| = 1}\left(
            T[j]
        \right)
    \end{align*}
    where we can only pick a previous off by one subsequence the last
    element of that subsequence is off by one ($|a_j - a_i| = 1$).\\

    The pseudocode and running time of this algorithm is the same as 
    the LIS with a modified conditional, and so it is not presented.

    \subsection*{Challenge Question: Picking Out Words}
    Let us say you have a block of text, but all of the spaces have been
    removed. For example, say we have \texttt{hellogeneralkenobi}. We
    want to figure out if we could split this block of text into
    multiple valid words.\\

    You are given an algorithm \texttt{isValidWord()} that returns true
    or false in $O(1)$ time (for sake of the question). Don't read on
    until you have given this some thought. The solution is on the
    next page.

    \pagebreak

    We represent $T[i]$ given by a boolean value determined by if the
    substring $0$ to $i$ can be broken into valid words. Using this, how
    can we get the recurrence relation?\\

    The idea is to loop through all the earlier indices and see if the
    last few characters is a word and if the $0$ to that index is also a 
    series of words.\\
    \begin{align*}
        \underbrace{(c_1 \ldots c_j)}_{\text{determined if word sequence by
            $T[j]$}}
        \overbrace{(c_{j+1} \ldots c_i)}^{\text{check if this is a word
            using \texttt{isValidWord}}}
    \end{align*}

    Hence, the recurrence relation can be given by:
    \begin{align*}
        T[i] = \bigvee_{j < i} (T[j] \land \texttt{isValidWord}(s_j, \ldots,
        s_i)
    \end{align*}

    The runtime of this algorithm is $O(n^2)$ as we perform $O(n)$ iterations
    to populate the table, and each entry requires $O(n)$ lookups giving a
    total runtime of $O(n^2)$.

\end{document}
