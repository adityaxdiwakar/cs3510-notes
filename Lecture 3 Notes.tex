\documentclass[14pt]{extarticle}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{scribe}
\usepackage{listings}
\usepackage{relsize}
\usepackage{xlop}
\usepackage{multirow,bigdelim,dcolumn,booktabs}
\usepackage[linesnumbered,vlined]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{trees}
\usetikzlibrary{positioning}

\Scribe{Aditya Diwakar \& David Burns}
\Lecturer{Frederic Faulkner}
\LectureNumber{3}
\LectureDate{January 18, 2022}
\LectureTitle{Introducing Recurrences}

\lstset{style=mystyle}
\setlength{\parindent}{0pt}

\begin{document}
	\MakeScribeTop

    Homework 1 due Saturday and Homework 2 will be released Saturday. We 
    recommend to regularly ask questions on Piazza and to go to Office Hours.

    \section{Fast Multiplication}
    In the previous lecture, we discussed how we can use a recursive
    strategy to multiply numbers by dividing the bits in half and then
    recursively multiplying.\\

    Our original naive method required 4 recursive multiplications, such as:
    \begin{align*}
        \underbrace{T(n)}_{\text{number of steps for $n$ sized input}}
        = \underbrace{O(n)}_{\text{nonrecursive work}}
        + 
        \underbrace{4T\left(\frac{n}{2}\right)}_{\text{multiplying n/2 bits, 4
        times}}
    \end{align*}
    This comes out to $T(n) = O(n^2)$. We can make a faster method by only
    performing 3 recursive calls, giving a runtime of:
    \begin{align*}
        T(n) = O(n) + 3T\left(\frac{n}{2}\right)
    \end{align*}
    ...which comes out to $O(n^{\log_2 3}) \approx O(n^{1.59})$, a faster
    algorithm.

    \section{Solving Runtimes}
    \begin{lemma}
        Let $f(n) = 1 + a + a^2 + \cdots + a^n$, then
        \begin{align*}
            f(n) = \begin{cases}
                O(1)    & a < 1    \\
                O(n)    & a = 1    \\
                O(a^n)  & a > 1
            \end{cases}
        \end{align*}
    \end{lemma}
    \textit{Proof.} For the case when $a > 1$, the conclusion of $O(a^n)$
    comes from
    \begin{align*}
        \frac{a^{n + 1} - 1}{a - 1}
    \end{align*}
    When $a = 1$, the conclusion of $O(n)$ comes from $\sum_{i = 1}^n 1 = n$
    and $a < 1$, this is a geometric series and has a constant sum 
    irrespective of $n$ given by:
    \begin{align*}
        s = \frac{1}{1 - a}
    \end{align*}

    This can be a strategy for converting certain equations to a Big-O form,
    but may not be the most useful for recursive definitions. For the 
    naive recursive multiplication, the recurrence relationship is given
    (and expanded) as:
    \begin{align*}
        T(n) &= O(n) + 4T\left(\frac{n}{2}\right)           \\
             &= c\cdot n + 4T\left(\frac{n}{2}\right)       \\
             &= c\cdot n + 4\left(c\cdot \left(\frac{n}{2}
                \right) + 4T\left(\frac{n}{4}\right)\right) \\
             &= cn\left(1 + \frac{4}{2}\right)
                + 16T\left(\frac{n}{4}\right)               \\
             &= cn\left(1 + \frac{4}{2}\right)
                + 16\left(
                    c\cdot \left(\frac{n}{4}\right)
                     + 4T\left(\frac{n}{8}\right)
                \right)                                     \\
             &= cn\left(1 + \frac{4}{2} + \left(
                    \frac{4}{2}       
                 \right)^2 \right)
                + 4^3\left(\frac{n}{2^3}\right)             \\
            &\ \vdots\quad\text{after $i$ steps}            \\
            &= 4^i T\left(\frac{n}{2^i}\right)
            + cn\left(1 + \frac{4}{2} 
                + \left(\frac{4}{2}\right)^2 
                + \cdots  
                + \left(\frac{4}{2}\right)^i\right)
    \end{align*}
    The base case for the recurrence is $T(1)$ so what value $i$ do we need
    such that $n / 2^i = 1$? In other words:
    \begin{align*}
        \frac{n}{2^i} = 1\implies 2^i = n\implies i = \log_2 n
    \end{align*}
    Hence, the above running time simplifies to
    \begin{align*}
        T(n) &= 4^{\log_2 n} T(1) + cn
            \underbrace{
                \left(1 + \frac{4}{2} + \left(\frac{4}{2}\right)^2
            + \cdots + \left(\frac{4}{2}\right)^{\log_2 n - 1}\right)}
            _{\text{geometric with $a > 1$; dominated by largest term}}
                                                                    \\
        &= 2^{2\cdot \log_2 n} + cn
            O\left(\left(\frac{4}{2}\right)^{\log_2 n - 1}\right)   \\
        &= n^2 + cn
            O\left(\left(\frac{4}{2}\right)^{\log_2 n - 1}\right)   \\
    \end{align*}
    Simplifying the second term shows:
    \begin{align*}
        cn\left(\frac{4}{2}\right)^{\log_2 n - 1}
        =
        cn\left(
            \frac{4^{\log_2 n - 1}}{2^{\log_2 n - 1}}
        \right)
        =
        cn\left(
            \frac{4^{\log_2 n - 1}}{O(n)}
        \right)
        =
       c\cdot \underbrace{4^{\log_2 n - 1}}_{O\left(n^2\right)}
       =
       cn^2
       = O(n^2)
    \end{align*}
    With this, we can finish the above:
    \begin{align*}
        T(n) = n^2 + O(n^2) = n^2 + c(n^2) = (c + 1)(n^2) 
        = \boxed{O\left(n^2\right)}
    \end{align*}

    We can follow this same process for the faster multiplication algorithm:
    \begin{align*}
        T(n) &= 3T\left(\frac{n}{2}\right) + O(n)                       \\
             &= 3\left(
                    3T\left(\frac{n}{4}\right) + \frac{cn}{2}
                \right) + cn                                            \\
             &= 9T\left(\frac{n}{4}\right) 
                + cn\left(1 + \frac{1}{2}\right)                        \\
             &= 9T\left(
                3T\left(\frac{n}{8}\right) + \frac{cn}{4}
                \right) + cn\left(1 + \frac{3}{2}\right)                \\
             &= 27T\left(\frac{n}{8}
                \right) + cn\left(1 + \frac{3}{2}
                + \frac{9}{4}\right)                                    \\
             &= 3^3T\left(\frac{n}{2^3}
                \right) + cn\left(1 + \frac{3}{2}
                + \left(\frac{3}{2}\right)^2\right)                     \\
    \end{align*}
    Now that a pattern has been found in the recurrence, we can see that
    \begin{align*}
        T(n) = 3^iT\left(\frac{n}{2^i}\right) + 
            cn\left(1 + \frac{3}{2} 
            + \left(\frac{3}{2}\right)^2 
            + \cdots
            + \left(\frac{3}{2}\right)^i\
        \right)
    \end{align*}
    We now compute for the last value of $i$:
    \begin{align*}
        \frac{n}{2^i} = 1 \implies n = 2^i \implies i = \log_2 n
    \end{align*}
    Finally, we can complete the simplification of the recurrence:
    \begin{align*}
        T(n) &= \underbrace{3^{\log_2 n}}_{n^{\log_2 3}}T(1) +  
            cn\underbrace{\left(1 + \frac{3}{2} 
            + \left(\frac{3}{2}\right)^2 
            + \cdots
            + \left(\frac{3}{2}\right)^{\log_2 n - 1}
        \right)}_{\text{dominated by last term}}                \\
             &= n^{\log_2 3} + cn\left(
                 \left(\frac{3}{2}\right)^{\log_2 n - 1}
             \right)                                            \\
             &= n^{\log_2 3} + cn\left(
                 \frac{3^{\log_2 n - 1}}{2^{\log_2 n - 1}}
             \right)                                            \\
             &= n^{\log_2 3} + cn\left(
                 \frac{3^{\log_2 n - 1}}{O(n)}
             \right)                                            \\
             &= n^{\log_2 3} + O(3^{\log_2 n})                  \\
             &= n^{\log_2 3} + O(n^{\log_2 3})                  \\
             &= n^{\log_2 3} + cn^{\log_2 3}                
              = (c+1)n^{\log_2 3}                               
              = \boxed{O(n^{\log_2 3})}
    \end{align*}

    \section{Towers of Hanoi}
    Time for a game! Towers of Hanoi is a game with 3 pegs and $n$
    disks. The goal is to get all of the $n$ pegs onto another peg.
    It is illegal to put a larger disk onto a smaller disk.\\

    If all the disks start on the left-most peg, then the strategy is
    to move all the top disks except the last onto another peg and then
    recursively solve the smaller sub-game with one fewer disk.\\

    For each step, there are two additional recursive calls, both of 
    which have a size of $n - 1$. Hence, $T(n) = 2T(n - 1) + O(1)$.
    We can solve this:
    \begin{align*}
        T(n) &= 2T(n - 1) + O(1)                            \\
             &= 2\left(2T(n - 2) + c) + c                   \\
             &= 2^2T(n - 2) + (1 + 2)c                      \\
             &= 2^3T(n - 3) + (1 + 2 + 4)c                  \\
             &= 2^4T(n - 4) + (1 + 2 + 4 + 8)c              \\
             &= \ \vdots                                    \\
             &= 2^iT(n - i) + (1 + 2 + \cdots + 2^{i-1})c   \\
             &= 2^nT(1) + O(2^n)                            \\
             &= 2^n + O(2^n)                                \\
             &= 2^n + c2^n 
             = (c + 1)2^n = \boxed{O(2^n)}
    \end{align*}
    
    A less detailed explanation and solution to the game is given here because
    lots of resources are available online with visualizations, animations,
    etc.

    \section{Binary Search}
    Binary search is a search algorithm for sorted arrays. The idea is
    that if you are given a sorted list and a number, each time you look
    at the middle, you can rule out half the elements in the list. Hence,
    binary search has a runtime of:
    \begin{align*}
        T(n) &= T\left(\frac{n}{2}\right) + O(1)            \\
             &= \left(
             T\left(\frac{n}{4}\right) + c
            \right) + c                                     \\
             &= \ \vdots                                    \\    
             &= T\left(\frac{n}{2^i}\right) + ic            \\
             &= T(1) + c\log n 
             = O(\log n)
    \end{align*}
    \pagebreak
    
    An implementation of this algorithm would be as follows:
    \begin{algorithm}
        \SetKwFunction{FMain}{BinarySearch}
        \SetKwProg{Fn}{Function}{:}{}
        \Fn{\FMain{$L, x$}}{
            \If{$|L| = 1$} {
                \Return $L[1] = x$
            }
            \If{$x > L\left[\frac{|L|}{2}\right]$} {
                \Return \Call{\FMain{$L\left[\frac{|L|}{2} : |L|\right]$}}
            }
            \Else{
                \Return \Call{\FMain{$L\left[0 : \frac{|L|}{2}\right]$}}
            }
        }
    \end{algorithm}

    \textbf{Remark:} Remember, binary search requires the input array to be
    sorted. Otherwise, the most optimal way to find an element would be to
    do a linear scan over the list (with complexity $O(n)$).

\end{document}
