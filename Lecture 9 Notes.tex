\documentclass[14pt]{extarticle}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{scribe}
\usepackage{listings}
\usepackage{relsize}
\usepackage{xlop}
\usepackage{multirow,bigdelim,dcolumn,booktabs}
\usepackage[linesnumbered,vlined]{algorithm2e}
\usepackage{tikz}
\usepackage{float}
\usetikzlibrary{trees}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows,shapes,automata,petri,positioning,calc,arrows.meta}
\tikzset{
    >=Stealth, % makes the arrow heads bold
    every state/.style={thick},
    every  edge/.append style={->, thick, font=\footnotesize},
}

\Scribe{Aditya Diwakar}
\Lecturer{Frederic Faulkner}
\LectureNumber{9}
\LectureDate{February 15, 2022}
\LectureTitle{More DP, Again}

\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\lstset{style=mystyle}
\setlength{\parindent}{0pt}

\begin{document}
	\MakeScribeTop

    \subsection*{Warm Up Example}
    Let's say we have a $1\times n$ plank that we want to cover with tiles. We
    have a total of 3 tiles available to us. We have a $1\times 1$ red
    square, a $1\times 1$ blue square, and a $1\times 2$ red rectangle.\\

    How many ways can we cover the $1\times n$ plank? For this, both order
    and color matters. How can we solve this using dynamic programming? Let's
    say our table is $T[i]$ represents the number of ways to arrange tiles on a
    $1\times i$ long plank.\\

    The recurrence relation for $T[i]$ can be made by noting that if we have
    $i-2$ plank, we can make this is an $i$ plank by placing a rectangle.
    Otherwise, if we have $i - 1$ plank, we can place either a red or blue
    square. Hence, the recurrence relation is:
    \begin{align*}
        T[n] = T[n-2] + 2T[n-1]
    \end{align*}

    and can be written with the following pseudocode:\\
    \begin{algorithm}[H]
        \SetKwFunction{FMain}{PlankFill}
        \SetKwProg{Fn}{Function}{:}{}
        \Fn{\FMain{$n$}}{
            \tcc{let $T$ be an empty $n$ long list}
            $T\gets []$                     \\
            $T[1] \gets 2$                  \\
            $T[2] \gets 5$                  \\
            \For{$i\in 2\to n$}{
                $T[i] \gets T[i-1] + 2T[i-2]$
            }
            \Return $T[n]$
        }
    \end{algorithm}

    The runtime of this algorithm is $O(n)$ as to build any $T[i]$, we perform
    $O(1)$ work by looking at $T[i-1]$ and $T[i-2]$. Since we have a total of
    $n$ entries to build, this takes $O(n)$ time.

    \subsection*{Longest Common Subsequence}
    Recall that a subsequence can have gaps, as long as the order is consistent
    between the underlying array and the subsequence.\\

    We are interested in the longest common subsequence between two lists $A$
    and $B$. In the example below, \textit{a} common subsequence is $\{2, 9\}$
    \begin{align*}
        \begin{matrix}
            A:\quad & 1 & \boxed{2} & 5 & \boxed{9} & 3 & 8 & 7         \\
            B:\quad & 5 & 3 & 4 & 7 & \boxed{2} & \boxed{9} & 1         
        \end{matrix}
    \end{align*}
    However, this is not the \textit{longest} common subsequence, which is
    $\{5, 3, 7\}$.
    \begin{align*}
        \begin{matrix}
            A:\quad & 1 & 2 & \boxed{5} & 9 & \boxed{3} & 8 & \boxed{7} \\
            B:\quad & \boxed{5} & \boxed{3} & 4 & \boxed{7} & 2 & 9 & 1         
        \end{matrix}
    \end{align*}

    Let us define $T[i]$ as the length of the LCS from $A[1:i]$ and $B[1:i]$,
    and compare $A_i$ and $B_i$. We have to approach this using cases. We know
    that either $A_i$ is equal to $B_i$ or they are different.\\

    If they are the same, then we can simply add this character to the LCS
    for the string not including $A_i, B_i$ meaning we can write $T[i]$
    as $T[i-1] + 1$.\\

    Another case: either $A_i$ or $B_i$ is not useful. If we include $A_i$
    and $B_i$, then this is not a common subsequence because these are
    obviously different.\\

    If we pick to attach $B_i$, then the length of this LCS is the length of
    the LCS of $A[1:i-1]$ and $B[i:1]$. However, our table entry definition
    did not allow for the two strings to differ in length. This does not work.
    \\

    Instead, it might make more sense to define our table entries as $T[i, j]$
    where this is the length of the LCS between $A[1:i]$ and $B[1:j]$.\\

    The case when $A_i$ and $B_j$ are the same, then $T[i, j] = 1 + T(i - 1,
    j - 1)$ which is the same as before.
    \pagebreak

    When $A_i \neq B_j$, then we have that either $A_i$ is useless to add,
    $B_j$ is useless to add, or both $A_i$ and $B_j$ are useless to add.
    These refer to the LCS of $T(i - 1, j), T(i, j-1), T(i-1, j-1)$.\\

    Since we want the longest common subsequence, we can simply take
    the maximum of all these (since all these are solutions to subproblems).\\

    Hence, in all, we can write the recurrence relation as:
    \begin{align*}
        T[i, j] = \begin{cases}
            T(i - 1, j - 1) + 1         & A_i = B_i         \\
            \max\left(
                T(i, - 1, j - 1), T(i - 1, j), T(i, j - 1)
            \right) & A_i \neq B_i
        \end{cases}
    \end{align*}
    Technically, the $T(i-1, j-1)$ is redundant because this will always be
    smaller than $T(i - 1, j)$ or $T(i, j - 1)$ and we don't need to include
    it.\\

    We also have base cases of $T(0, j) = 0$ and $T(i, 0) = 0$ for all $i, j$
    because there is no common subsequence for a string with zero length.\\
    \begin{algorithm}[H]
        \SetKwFunction{FMain}{LCS}
        \SetKwProg{Fn}{Function}{:}{}
        \Fn{\FMain{$A, B$}}{
            \tcc{let $T$ be an empty $n + 1$ long list}
            $T\gets []$                     \\
            \For{$i \in 1\to n$}{
                $T[i, 0] \gets 0$
            }
            \For{$j \in 1\to n$}{
                $T[0, j] \gets 0$
            }
            \For{$i\in 0 \to n$}{
                \For{$j\in 0\to n$}{
                    \If{$A[i] = B[j]$}{
                        $T[i, j]\gets 1 + T[i-1,j-1]$
                    }
                    \Else{
                        $T[i,j] = max\left(T(i - 1, j), T(i, j - 1)\right)$
                    }
                }
            }
            \Return $T[n,n]$
        }
    \end{algorithm}
    The runtime of this algorithm is $O(n^2)$ as the base case takes $O(n)$
    time to set and the nested for loop is $O(n^2)$ giving a total runtime of
    $O(n^2)$.

    \subsection*{LCS for 3 Lists}
    How can we adapt the LCS for 3 input lists ($A, B, C$)? Can we simply
    say that the $LCS(A, B, C) = LCS(LCS(A, B), C)$? No! But, then how do we
    do it?\\

    The table now holds values where $T[i, j, k]$ is the longest common
    subsequence between $A[1:i], B[1:i], C[1:k]$ (the table is now three
    dimensional).\\

    For the recurrence, notice that if $A_i = B_i = C_i$, then we can simply
    take $T[i, j, k] = 1 + T[i-1, j-1, k-1]$. Otherwise, if they differ, we can
    simply take the max of all situations where we withhold a letter.
    \begin{align*}
        T[i, j, k] = \max\left(T[i-1,j,k] + T[i,j-1,k] + T[i,j,k-1]\right)
    \end{align*}
    We could also do $i-1,j-1,k$ or $i-1,j,k-1$ because those subproblems are
    strictly smaller than other subproblems already included, hence we can
    exclude those.\\

    The runtime of this algorithm is $O(n^3)$ as we now have to traverse over
    the three dimensional table (rather than a 2D table).

    \subsection*{Challenge}
    Let's start with an $n\times n$ matrix of integers and the goal is to get
    from the top left to the bottom right and we want the path with the
    smallest sum (we can only move right and down). Design a DP algorithm
    to solve this problem.

\end{document}
